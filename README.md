#Golang best practices

##About
here is my opinion about golang sofware development best practices

##Файловая структура приложения
```
.
├── cmd
│   ├── api
│   │   └── api.go
│   ├── callback
│   │   └── callback.go
│   └── dispatcher
│       └── dispatcher.go
├── configs
│   ├── conf.yaml.example
│   └── logger.yaml.example
├── internal
│   ├── RMQ
│   │   └── RMQ.go
│   ├── api
│   │   └── api.go
│   ├── callback
│   │   └── callback.go
│   ├── config
│   │   └── config.go
│   ├── dispatcher
│   │   └── dispatcher.go
│   ├── logger
│   │   └── logger.go
│   ├── middleware
│   │   └── middleware.go
│   ├── DB
│   │   └── DB.go
│   └── rest
│       └── client
│           └── client.go
├── schemas
│   └── schemas.sql
├── Gopkg.toml
└── ReadME.md
```
Базовая часть структуры приложения формируется по [стандарту](https://github.com/golang-standards/project-layout). Объяснения можно почитать [тут](https://ieftimov.com/golang-package-multiple-binaries).

## Пояснения
* **cmd** - размещаем файлы, которые при сборке станут **исполняемыми**.  Все файлы входят в состав **package main**.
* **configs** - размещаем конфиги, возможно, со значениями по-умолчанию, возможно, - только примеры значений. Конфиги со значениями по умолчанию должны иметь постфикс 'example' (напр. api.yaml.example).
* **internal** - размещаем модули, которые могут использоваться по **всему** проекту, но **не могут** использоваться в **сторонних** проектах. Каждый **file.go** представляет собственный **package**.
* **schemas** - дамп БД (нужно заменить на первую миграцию)
* **migrations** - список файлов миграции к [sql-migrate](https://github.com/rubenv/sql-migrate)
* **Gopkg.toml** - список зависимостей, составленный утилитой [dep](https://golang.github.io/dep/docs/introduction.html)

## Правила именования
* Правила именования переменных, структур, интерфейсов, пакетов описано в [офф. док-ции](https://golang.org/doc/effective_go.html). Если не будет аргументов в пользу иных правил, то правила описанные в офф. док-ции принимаются **as is**.

## Форматирование исходников
* Перед commit-ом необходимо форматировать исходники, используя утилиту [gofmt](https://golang.org/pkg/fmt/).
* Также необходимо проверять исходники [linter-ом](https://github.com/golang/lint), пример:
```
$ golint -set_exit_status ./...
```
* Со стороны репозитория будет настроен prehook, который также будет запускать linter, и если он не будет пройден, то MR будет отклоняться.

## Зависимости от сторонних модулей
* Если стандартных модулей начнет не хватать, то придётся добавлять сторонние модули.
* Необходимо использовать утилиту [dep](https://golang.github.io/dep/docs/introduction.html) для добавления новых зависимостей. Первоначальная инициализация выполняется так (может работать долго):
```
$ dep init -v
```
* Результатом выполнения этой команды станет появление директории **vendor** и файлов **Gopkg.lock** и **Gopkg.toml**. 
  * **vendor** и **Gopkg.lock** должны быть **исключены**(!!!) из версионирования
  * **Gopkg.toml** следует добавить в репозиторий
* Если добавили новую зависимость, то нужно обновить зависимости в проекте:
```
$ dep ensure -v
```
* Если обновилась сама зависимость и нужно её обновить в проекте, то:
```
$ dep ensure -v -update
```

## Работа с ошибками
* Внутри проекта/приложения должны использоваться **собственные** ошибки
* Не использовать ошибки сторонних модулей за пределами функции, где используются сторонний модуль
* Список ошибок приложения лучше всего оформлять в виде переменных
* Еще лучше: помещать ошибки в **контейнер**  (структуру) с ошибками, который реализует метод **Error()**. Таким образом, можно будет наращивать информативность ошибок.

## Работа со структурами
* Стараться не инициализировать структуру напрямую. Для получения переменной типа структуры, лучше подготовить функцию **NewStructName**
* Стараться избегать публичных полей в структурах, поля должны быть приватными, а к ним следует писать **getters/setters**.

## Логирование
* Какой бы логгер вы не выбрали, лучше скрыть его реализацию за интерфейсом, который обязательно реализует следующие методы:
  * Trace
  * Debug
  * Info
  * Warn
  * Error
  * Crit/Panic/Fatal
  * и их аналоги Levelf для форматированного вывода

## Интерфейсы вместо объектов
* Использование практики сокрытии реализации стороннего модуля (по примеру логгера), это верный путь, т.к.:
  1. Вы оставляете возможность **заменить** конкретную реализацию, не меняя код клиентов модуля.
  2. Интерфейсы позволяют расширять функциональность, см. [embedding](https://travix.io/type-embedding-in-go-ba40dd4264df) и [go-inheritance](https://medium.com/@simplyianm/why-gos-structs-are-superior-to-class-based-inheritance-b661ba897c67)
  3. Упрощают написание автоматических тестов (требует проверки)
* Нужно внимательно подходит к выбору типов аргументов, принимаемых функцией и к типу возвращаемых результатов
* Особенно, когда речь идёт об использовании зависимостей
